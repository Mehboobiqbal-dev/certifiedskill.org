{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///home/user/get-certified/pages/models/user.ts"],"sourcesContent":["import mongoose from \"mongoose\";\n\nconst UserSchema = new mongoose.Schema({\n  name: {\n    type: String,\n    required: true,\n  },\n  email: {\n    type: String,\n    required: true,\n    unique: true,\n  },\n  password: {\n    type: String,\n    required: false,\n  },\n});\n\nconst User = mongoose.models.User || mongoose.model(\"User\", UserSchema);\n\nexport default User;\n"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,aAAa,IAAI,yGAAA,CAAA,UAAQ,CAAC,MAAM,CAAC;IACrC,MAAM;QACJ,MAAM;QACN,UAAU;IACZ;IACA,OAAO;QACL,MAAM;QACN,UAAU;QACV,QAAQ;IACV;IACA,UAAU;QACR,MAAM;QACN,UAAU;IACZ;AACF;AAEA,MAAM,OAAO,yGAAA,CAAA,UAAQ,CAAC,MAAM,CAAC,IAAI,IAAI,yGAAA,CAAA,UAAQ,CAAC,KAAK,CAAC,QAAQ;uCAE7C","debugId":null}},
    {"offset": {"line": 170, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 176, "column": 0}, "map": {"version":3,"sources":["file:///home/user/get-certified/lib/db.js"],"sourcesContent":["import mongoose from 'mongoose';\n\n// Ensure that the MONGO_URI is defined\nif (!process.env.MONGO_URI) {\n  throw new Error('Please define the MONGO_URI environment variable');\n}\n\n// Check if there's already a cached connection.\n// The global object in Node.js is similar to the window object in browsers.\nlet cached = global.mongoose;\n\nif (!cached) {\n  // If there's no existing cache, initialize one.\n  cached = global.mongoose = { conn: null, promise: null };\n}\n\nasync function connectToDatabase() {\n  // If there's an existing connection, return it\n  if (cached.conn) {\n    return cached.conn;\n  }\n  \n  // Otherwise, if there's no promise, create one and cache it.\n  if (!cached.promise) {\n    const options = { useNewUrlParser: true, useUnifiedTopology: true };\n    cached.promise = mongoose\n      .connect(process.env.MONGO_URI, options)\n      .then((mongooseInstance) => {\n        // Return an object that contains the DB connection\n        return { db: mongooseInstance.connection.db };\n      });\n  }\n\n  // Await the promise to finish and cache the connection.\n  cached.conn = await cached.promise;\n  return cached.conn;\n}\n\nexport default connectToDatabase;\n"],"names":[],"mappings":";;;AAAA;;AAEA,uCAAuC;AACvC,IAAI,CAAC,QAAQ,GAAG,CAAC,SAAS,EAAE;IAC1B,MAAM,IAAI,MAAM;AAClB;AAEA,gDAAgD;AAChD,4EAA4E;AAC5E,IAAI,SAAS,OAAO,QAAQ;AAE5B,IAAI,CAAC,QAAQ;IACX,gDAAgD;IAChD,SAAS,OAAO,QAAQ,GAAG;QAAE,MAAM;QAAM,SAAS;IAAK;AACzD;AAEA,eAAe;IACb,+CAA+C;IAC/C,IAAI,OAAO,IAAI,EAAE;QACf,OAAO,OAAO,IAAI;IACpB;IAEA,6DAA6D;IAC7D,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,MAAM,UAAU;YAAE,iBAAiB;YAAM,oBAAoB;QAAK;QAClE,OAAO,OAAO,GAAG,yGAAA,CAAA,UAAQ,CACtB,OAAO,CAAC,QAAQ,GAAG,CAAC,SAAS,EAAE,SAC/B,IAAI,CAAC,CAAC;YACL,mDAAmD;YACnD,OAAO;gBAAE,IAAI,iBAAiB,UAAU,CAAC,EAAE;YAAC;QAC9C;IACJ;IAEA,wDAAwD;IACxD,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IAClC,OAAO,OAAO,IAAI;AACpB;uCAEe","debugId":null}},
    {"offset": {"line": 218, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 224, "column": 0}, "map": {"version":3,"sources":["file:///home/user/get-certified/app/api/auth/%5B...nextauth%5D/route.js"],"sourcesContent":["import NextAuth from \"next-auth\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\nimport GithubProvider from \"next-auth/providers/github\";\nimport User from \"../../../../pages/models/user\";\nimport connectToDatabase from \"../../../../lib/db\";\nimport bcrypt from \"bcryptjs\";\n\nconst authOptions = {\n  session: {\n    strategy: \"jwt\",\n  },\n  providers: [\n    GithubProvider({\n      clientId: process.env.GITHUB_ID,\n      clientSecret: process.env.GITHUB_SECRET,\n    }),\n    CredentialsProvider({\n      name: \"Credentials\",\n      credentials: {\n        email: { label: \"Email\", type: \"text\", placeholder: \"you@example.com\" },\n        password: { label: \"Password\", type: \"password\" },\n      },\n      async authorize(credentials) {\n        try {\n          await connectToDatabase();\n          const user = await User.findOne({ email: credentials?.email }).exec();\n          if (!user) throw new Error(\"No user found with that email.\");\n          const isValidPassword = await bcrypt.compare(\n            credentials?.password ?? \"\",\n            user.password\n          );\n          if (!isValidPassword) throw new Error(\"Invalid password.\");\n          return user;\n        } catch (error) {\n          console.error(\"Authorize error:\", error);\n          return null;\n        }\n      },\n    }),\n  ],\n  callbacks: {\n    async signIn({ account, profile }) {\n      // For provider sign in, create a new user if one doesn't exist.\n      if (account?.provider === \"github\") {\n        await connectToDatabase();\n        const existingUser = await User.findOne({ email: profile?.email }).exec();\n        if (!existingUser) {\n          await User.create({\n            name: profile?.name,\n            email: profile?.email,\n            role: 'student' // Default role; adjust as needed.\n          });\n        }\n      }\n      return true;\n    },\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user._id.toString();\n        token.email = user.email;\n        token.name = user.name;\n        token.role = user.role || 'student';\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (token) {\n        session.user = {\n          id: token.id,\n          email: token.email,\n          name: token.name,\n          role: token.role || 'student',\n        };\n      }\n      return session;\n    },\n  },\n  pages: {\n    signIn: \"/sign-in\",\n  },\n  secret: process.env.NEXTAUTH_SECRET,\n};\n\nconst handler = NextAuth(authOptions);\nexport const GET = handler;\nexport const POST = handler;\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEA,MAAM,cAAc;IAClB,SAAS;QACP,UAAU;IACZ;IACA,WAAW;QACT,CAAA,GAAA,qJAAA,CAAA,UAAc,AAAD,EAAE;YACb,UAAU,QAAQ,GAAG,CAAC,SAAS;YAC/B,cAAc,QAAQ,GAAG,CAAC,aAAa;QACzC;QACA,CAAA,GAAA,0JAAA,CAAA,UAAmB,AAAD,EAAE;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;oBAAQ,aAAa;gBAAkB;gBACtE,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI;oBACF,MAAM,CAAA,GAAA,2GAAA,CAAA,UAAiB,AAAD;oBACtB,MAAM,OAAO,MAAM,yHAAA,CAAA,UAAI,CAAC,OAAO,CAAC;wBAAE,OAAO,aAAa;oBAAM,GAAG,IAAI;oBACnE,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM;oBAC3B,MAAM,kBAAkB,MAAM,mIAAA,CAAA,UAAM,CAAC,OAAO,CAC1C,aAAa,YAAY,IACzB,KAAK,QAAQ;oBAEf,IAAI,CAAC,iBAAiB,MAAM,IAAI,MAAM;oBACtC,OAAO;gBACT,EAAE,OAAO,OAAO;oBACd,QAAQ,KAAK,CAAC,oBAAoB;oBAClC,OAAO;gBACT;YACF;QACF;KACD;IACD,WAAW;QACT,MAAM,QAAO,EAAE,OAAO,EAAE,OAAO,EAAE;YAC/B,gEAAgE;YAChE,IAAI,SAAS,aAAa,UAAU;gBAClC,MAAM,CAAA,GAAA,2GAAA,CAAA,UAAiB,AAAD;gBACtB,MAAM,eAAe,MAAM,yHAAA,CAAA,UAAI,CAAC,OAAO,CAAC;oBAAE,OAAO,SAAS;gBAAM,GAAG,IAAI;gBACvE,IAAI,CAAC,cAAc;oBACjB,MAAM,yHAAA,CAAA,UAAI,CAAC,MAAM,CAAC;wBAChB,MAAM,SAAS;wBACf,OAAO,SAAS;wBAChB,MAAM,UAAU,kCAAkC;oBACpD;gBACF;YACF;YACA,OAAO;QACT;QACA,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,GAAG,CAAC,QAAQ;gBAC5B,MAAM,KAAK,GAAG,KAAK,KAAK;gBACxB,MAAM,IAAI,GAAG,KAAK,IAAI;gBACtB,MAAM,IAAI,GAAG,KAAK,IAAI,IAAI;YAC5B;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,OAAO;gBACT,QAAQ,IAAI,GAAG;oBACb,IAAI,MAAM,EAAE;oBACZ,OAAO,MAAM,KAAK;oBAClB,MAAM,MAAM,IAAI;oBAChB,MAAM,MAAM,IAAI,IAAI;gBACtB;YACF;YACA,OAAO;QACT;IACF;IACA,OAAO;QACL,QAAQ;IACV;IACA,QAAQ,QAAQ,GAAG,CAAC,eAAe;AACrC;AAEA,MAAM,UAAU,CAAA,GAAA,uIAAA,CAAA,UAAQ,AAAD,EAAE;AAClB,MAAM,MAAM;AACZ,MAAM,OAAO","debugId":null}},
    {"offset": {"line": 326, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}